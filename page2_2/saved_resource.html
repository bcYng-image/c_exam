<!DOCTYPE html>
<!-- saved from url=(0176)http://exam.cuit.edu.cn/index.php?r=front%2Ftest%2Fquestions&course=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&know=04AEE910FD38C3E53FC3CDA24AD8CA95&stage=%E4%BA%8C%E9%98%B6%E6%AE%B5 -->
<html><script async="false" type="text/javascript" src="chrome-extension://fnjhmkhhmkbjkkabndcnnogagogbneec/in-page.js"></script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
    <!-- Bootstrap 3.3.6 -->
    <link rel="stylesheet" href="./bootstrap.min(1).css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- jQuery 2.2.3 -->
    <script src="./jquery-2.2.3.min.js"></script>
            <!-- <head></head>中代码块 -->

<style type="text/css">
*{
    font-size: 14px;
    font-family: "微软雅黑";
    font-weight: normal;
    color:black;
}
button{
    border:none;
    outline-style:none !important;
    text-align: left !important;
}
input{
    outline-style:none !important;
}
input[type=radio]{
    margin-left:20px;
}
input[maxlength="50"]{
    margin-right: 5px;
    margin-bottom: 5px;
}
#time{
    margin-top: -18px;
     margin-bottom: 10px;
     float:right;
    width:100%;
    height:25px;
    line-height: 25px;
    text-align: right;
    border-bottom: 1px solid gray;
}
.noFlow{
    width:100%;
    overflow:hidden;
    text-overflow: ellipsis;
}

.Answer11{
    display: none;
    font-weight:bold;
    float:left;
    margin-left:10px;
    color:red;
}
.Answer22{
    margin-top: 10px;
    width:76%;
    height:320px;
    border:1px solid gray;
    padding:5px;
    overflow:auto;
    display: none;
}
.btn-default{

    border-radius: 5px;
    border:1px solid #F0F0F0;
    color:black;
}
.minContent{
    margin:10px auto;
}
.message{
    display: none;
    position: relative;
    top: -45px;
    left: -70px;
    color:red;
}
.fileName:link,.fileName:hover,.fileName:visited,.fileName:active{
	margin-right: 15px;
	color:blue;
	text-decoration: underline;
}

textarea{
    height:400px !important;
    width:100% !important;
    color:black !important;
    overflow-y: auto;
}
hr{
    border:1px dashed gray;
}
body{
    /* background-color: #f9f9f9; */
}
.row{
  margin-top: 20px;
}
.navbar-default {
    border-radius: 0px;
    background-color: #fff;
    box-sizing: border-box;
    box-shadow: 0 3px 5px rgba(0,0,0,.3);
}
</style>


</head><body>
    

    

<section class="content">
    <div class="row">
        <div class="col-xs-10 col-xs-offset-1">
            <nav class="navbar navbar-default topNav" role="navigation">
                <div class="container-fluid">
                    <!-- Brand and toggle get grouped for better mobile display -->
                    <div class="navbar-header">

                    </div>

                    <!-- Collect the nav links, forms, and other content for toggling -->
                    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                        <ul class="nav navbar-nav ">
                            <li class="topLi"><a href="http://exam.cuit.edu.cn/index.php?r=front%2Ftest%2Fquestions&amp;course=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;know=04AEE910FD38C3E53FC3CDA24AD8CA95&amp;stage=%E4%BA%8C%E9%98%B6%E6%AE%B5#">题型：</a></li>
                                                            <li class="topLi" name="1000206"><a href="http://exam.cuit.edu.cn/index.php?r=front%2Ftest%2Fquestions&amp;course=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;know=04AEE910FD38C3E53FC3CDA24AD8CA95&amp;stage=%E4%BA%8C%E9%98%B6%E6%AE%B5#">编程题</a></li>
                                                    </ul>

                    </div><!-- /.navbar-collapse -->
                </div><!-- /.container-fluid -->
            </nav>
        </div>
    </div>
    <div class="row" style="margin:10px auto; padding-top:-30px;">
        <div class="col-xs-11 minContent col-xs-offset-2" style="margin-left:4%; margin-top:-30px;">
            <div class="row">
                <div class="col-xs-12">
                    <h2> 数据结构</h2>
                </div>
            </div>
            <form id="submit-paper1" action="http://exam.cuit.edu.cn/index.php?r=front%2Ftest%2Fquestions&amp;course=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;know=04AEE910FD38C3E53FC3CDA24AD8CA95&amp;stage=%E4%BA%8C%E9%98%B6%E6%AE%B5" method="post" role="form">
<input type="hidden" name="_csrf" value="dTg5ZDJCV0UafXUlZ3EnNydBdRZjM3ozIVV7V212MQtFfVNdfgMfAw==">                            <div class="">
                    <div class="row">
                        <div class="col-xs-12">
                            <button type="button" id="1000206-href" class="btn btn-lg btn-default btn-block" onclick="toggle(1000206)">编程题</button>
                        </div>    <!--  题型按钮 -->
                    </div>
                    <h1></h1>
                    <div style="display: none" id="1000206">
                                                    <div class="row 1000206" id="1000206">
                                <button name="1" "="" type="button" class="but1 btn btn-default col-xs-10 col-xs-offset-1" onclick="toggle(1)" style="background-color: rgb(251, 173, 108);"><div class="noFlow">(1 分) 1.LB2108P   删除带头结点的循环链表中元素为m的结点</div></button>

                                <div class="col-xs-10 col-xs-offset-1 _patent" style="display: none; float:left; padding-top: 10px;" id="1">
                                    <p><span style="font-family:宋体">删除带头结点的循环链表中元素为</span>m<span style="font-family:宋体">的结点。</span></p><p><img src="./1599278935573112.jpg" title="1599278935573112.jpg" alt="cirlink_delete.jpg"></p>                                    <hr><span style="float:left; margin-right:15px;"></span><input class="answ bigAnswer" type="button" style="float:left; margin-right:20px;" value="显示答案"><input style="margin-right:15px;" type="button" name="21ED7735A68F6A6ECF0FC32BC723B86B" id="compile21ED7735A68F6A6ECF0FC32BC723B86B" value="编译该题" onclick="compile(&#39;21ED7735A68F6A6ECF0FC32BC723B86B&#39;)"><input type="button" value="还原代码" class="resetCode">
            <textarea class="Answer22 cairo_scaled_font_text_extents(scaledfont, text)" style="line-height:25px;">void del(pCircleLink L, int m)
{
	pCircleLink p, q;
	p = L;

	while (p-&gt;next != L)
	{
		if (p-&gt;next-&gt;data == m)
		{
			q = p-&gt;next;
			p-&gt;next = q-&gt;next;
			free(q);
		}
		else
		{
			p = p-&gt;next;
		}
	}
}</textarea><label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分数:</label>&nbsp;&nbsp;<strong class="StuScore" style="color:red;" id="score21ED7735A68F6A6ECF0FC32BC723B86B"></strong><div class="message" style="left:0px;">请勿频繁操作</div><textarea style="display:none;" class="anCode">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _CircleLink
{
	int data;
	struct _CircleLink *next;
} CircleLink, *pCircleLink;

void Destroy(pCircleLink L);
int create(pCircleLink L);
void output(pCircleLink L);
void del(pCircleLink L, int m);

int main(void)
{
	int n;
	CircleLink L;

	L.next = &amp;L;

	if (create(&amp;L) &lt; 0)
	{
		return 0;
	}
	printf("原始循环链表为:\n");
	output(&amp;L);
	printf("输入需要删除的元素:");
	scanf("%d", &amp;n);
	del(&amp;L, n);
	printf("output:\n");
	output(&amp;L);
	Destroy(&amp;L);
	return 0;
}

void Destroy(pCircleLink L)
{
	pCircleLink p, q;
	p = q = L-&gt;next;
	while (p-&gt;next != L)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}
}

int create(pCircleLink L)
{
	int number;
	pCircleLink p, q;

	p = L;
	printf("输入创建循环链表的元素(0表示结束):\n");
	scanf("%d", &amp;number);
	while (number != 0)
	{
		q = (pCircleLink)malloc(sizeof(CircleLink));
		if (q == NULL)
		{
			return -1;
		}
		q-&gt;data = number;
		q-&gt;next = p-&gt;next;
		p-&gt;next = q;
		p = q;
		scanf("%d", &amp;number);
	}
	return 1;
}

void output(pCircleLink L)
{
	pCircleLink p = L;
	while (p-&gt;next != L)
	{
		p = p-&gt;next;
		printf("%d ", p-&gt;data);
	}
	printf("\n");
}

/******start******/

/******end******/</textarea><h1></h1><textarea class="col-xs-8 Code tkCode" rows="20" name="21ED7735A68F6A6ECF0FC32BC723B86B" style="color: red;">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _CircleLink
{
	int data;
	struct _CircleLink *next;
} CircleLink, *pCircleLink;

void Destroy(pCircleLink L);
int create(pCircleLink L);
void output(pCircleLink L);
void del(pCircleLink L, int m);

int main(void)
{
	int n;
	CircleLink L;

	L.next = &amp;L;

	if (create(&amp;L) &lt; 0)
	{
		return 0;
	}
	printf("原始循环链表为:\n");
	output(&amp;L);
	printf("输入需要删除的元素:");
	scanf("%d", &amp;n);
	del(&amp;L, n);
	printf("output:\n");
	output(&amp;L);
	Destroy(&amp;L);
	return 0;
}

void Destroy(pCircleLink L)
{
	pCircleLink p, q;
	p = q = L-&gt;next;
	while (p-&gt;next != L)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}
}

int create(pCircleLink L)
{
	int number;
	pCircleLink p, q;

	p = L;
	printf("输入创建循环链表的元素(0表示结束):\n");
	scanf("%d", &amp;number);
	while (number != 0)
	{
		q = (pCircleLink)malloc(sizeof(CircleLink));
		if (q == NULL)
		{
			return -1;
		}
		q-&gt;data = number;
		q-&gt;next = p-&gt;next;
		p-&gt;next = q;
		p = q;
		scanf("%d", &amp;number);
	}
	return 1;
}

void output(pCircleLink L)
{
	pCircleLink p = L;
	while (p-&gt;next != L)
	{
		p = p-&gt;next;
		printf("%d ", p-&gt;data);
	}
	printf("\n");
}

/******start******/

/******end******/</textarea>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                </div>
                            </div>
                            <h6></h6>
                                                        <div class="row 1000206" id="1000206">
                                <button name="1" "="" type="button" class="but1 btn btn-default col-xs-10 col-xs-offset-1" onclick="toggle(2)" style="background-color: rgb(251, 173, 108);"><div class="noFlow">(1 分) 2.LB2203   双向链表插入元素</div></button>

                                <div class="col-xs-10 col-xs-offset-1 _patent" style="display: none; float:left; padding-top: 10px;" id="2">
                                    <p>该程序是带头结点双向链表的基本操作。完成Insert函数功能，该函数将数据data插入到双向链表的第pos个位置上。</p><p><img style="float:none" title="dlink2203-1.jpg" src="./2369647b-d80d-43f4-8b8a-e2624e38f243.jpg"></p><p><img style="float:none" title="dlink2203-2.jpg" src="./c55cea76-6bf6-47f5-9453-23df75a08e3e.jpg"></p><p>&nbsp;</p>                                    <hr><span style="float:left; margin-right:15px;"></span><input class="answ bigAnswer" type="button" style="float:left; margin-right:20px;" value="显示答案"><input style="margin-right:15px;" type="button" name="3051e5610cf74ad48455d15a6d8e9f17" id="compile3051e5610cf74ad48455d15a6d8e9f17" value="编译该题" onclick="compile(&#39;3051e5610cf74ad48455d15a6d8e9f17&#39;)"><input type="button" value="还原代码" class="resetCode">
            <textarea class="Answer22 cairo_scaled_font_text_extents(scaledfont, text)" style="line-height:25px;">int Insert(pDoubleLink L, int data, int pos)
{
	int i;
	pDoubleLink p, s;
	
	p = L;
	
	i = 1;
	while (p != NULL)
	{
		if (i &gt;= pos || i &lt; 1)
		{
			break;
		}
		i++;
		p = p-&gt;next;
	}

	if (pos &lt; 1 || p == NULL)
	{
		return -1;
	}
	s = (pDoubleLink)malloc(sizeof(DoubleLink));
	s-&gt;data = data;
	s-&gt;next = p-&gt;next;
	s-&gt;prior = p;
	if (p-&gt;next != NULL)
	{
		p-&gt;next-&gt;prior = s;
	}
	p-&gt;next = s;

	return 0;
}</textarea><label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分数:</label>&nbsp;&nbsp;<strong class="StuScore" style="color:red;" id="score3051e5610cf74ad48455d15a6d8e9f17"></strong><div class="message" style="left:0px;">请勿频繁操作</div><textarea style="display:none;" class="anCode">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _DoubleLink
{
	int data;
	struct _DoubleLink *prior;
	struct _DoubleLink *next;
	int length;
} DoubleLink, *pDoubleLink;

void Create(pDoubleLink L, int n);
void Doubleout(pDoubleLink L);
void Destroy(pDoubleLink L);
int Insert(pDoubleLink L, int data, int pos);

int main(void)
{
	int n, data, pos, flag;
	pDoubleLink L = (pDoubleLink)malloc(sizeof(DoubleLink));		//头结点
	L-&gt;prior = L-&gt;next = NULL;
	L-&gt;length = 0;

	printf("输入需要创建的链表元素个数:");
	scanf("%d", &amp;n);
	Create(L, n);

	printf("输入需要插入的元素值:");
	scanf("%d", &amp;data);
	printf("输入需要插入的元素的位置:");
	scanf("%d", &amp;pos);

	flag = Insert(L, data, pos);
	if (flag &lt; 0)
	{
		printf("output:\nThe Position is Wrong!\n");
	}

	if (flag &gt;= 0)
	{
		Doubleout(L);
	}

	Destroy(L);
	free(L);
	return 0;
}

/*头插法创建双向链表*/
void Create(pDoubleLink L, int n)
{
	int i, data;
	pDoubleLink p;
	printf("输入创建链表各元素的值:\n");
	for (i = 0; i &lt; n; i++)
	{
		scanf("%d", &amp;data);

		p = (pDoubleLink)malloc(sizeof(DoubleLink));
		p-&gt;data = data;
		p-&gt;next = L-&gt;next;
		p-&gt;prior = L;

		if (L-&gt;next != NULL)
		{
			L-&gt;next-&gt;prior = p;
			L-&gt;next = p;
		}
		else
		{
			L-&gt;next = p;
		}
	}
	L-&gt;length = n;
}

void Doubleout(pDoubleLink L)
{
	pDoubleLink p = L;
	printf("output:\n");
	while (p-&gt;next != NULL)
	{
		printf("%d ", p-&gt;next-&gt;data);
		p = p-&gt;next;
	}
	printf("\n");
	while (p != L)
	{
		printf("%d ", p-&gt;data);
		p = p-&gt;prior;
	}
	printf("\n");
}

void Destroy(pDoubleLink L)
{
	pDoubleLink p, q;
	
	p = q = L-&gt;next;
	while (p != NULL)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}
}

/******start******/

/******end******/</textarea><h1></h1><textarea class="col-xs-8 Code tkCode" rows="20" name="3051e5610cf74ad48455d15a6d8e9f17" style="color: red;">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _DoubleLink
{
	int data;
	struct _DoubleLink *prior;
	struct _DoubleLink *next;
	int length;
} DoubleLink, *pDoubleLink;

void Create(pDoubleLink L, int n);
void Doubleout(pDoubleLink L);
void Destroy(pDoubleLink L);
int Insert(pDoubleLink L, int data, int pos);

int main(void)
{
	int n, data, pos, flag;
	pDoubleLink L = (pDoubleLink)malloc(sizeof(DoubleLink));		//头结点
	L-&gt;prior = L-&gt;next = NULL;
	L-&gt;length = 0;

	printf("输入需要创建的链表元素个数:");
	scanf("%d", &amp;n);
	Create(L, n);

	printf("输入需要插入的元素值:");
	scanf("%d", &amp;data);
	printf("输入需要插入的元素的位置:");
	scanf("%d", &amp;pos);

	flag = Insert(L, data, pos);
	if (flag &lt; 0)
	{
		printf("output:\nThe Position is Wrong!\n");
	}

	if (flag &gt;= 0)
	{
		Doubleout(L);
	}

	Destroy(L);
	free(L);
	return 0;
}

/*头插法创建双向链表*/
void Create(pDoubleLink L, int n)
{
	int i, data;
	pDoubleLink p;
	printf("输入创建链表各元素的值:\n");
	for (i = 0; i &lt; n; i++)
	{
		scanf("%d", &amp;data);

		p = (pDoubleLink)malloc(sizeof(DoubleLink));
		p-&gt;data = data;
		p-&gt;next = L-&gt;next;
		p-&gt;prior = L;

		if (L-&gt;next != NULL)
		{
			L-&gt;next-&gt;prior = p;
			L-&gt;next = p;
		}
		else
		{
			L-&gt;next = p;
		}
	}
	L-&gt;length = n;
}

void Doubleout(pDoubleLink L)
{
	pDoubleLink p = L;
	printf("output:\n");
	while (p-&gt;next != NULL)
	{
		printf("%d ", p-&gt;next-&gt;data);
		p = p-&gt;next;
	}
	printf("\n");
	while (p != L)
	{
		printf("%d ", p-&gt;data);
		p = p-&gt;prior;
	}
	printf("\n");
}

void Destroy(pDoubleLink L)
{
	pDoubleLink p, q;
	
	p = q = L-&gt;next;
	while (p != NULL)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}
}

/******start******/

/******end******/</textarea>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                </div>
                            </div>
                            <h6></h6>
                                                        <div class="row 1000206" id="1000206">
                                <button name="1" "="" type="button" class="but1 btn btn-default col-xs-10 col-xs-offset-1" onclick="toggle(3)" style="background-color: rgb(251, 173, 108);"><div class="noFlow">(1 分) 3.LB2109P   将带头结点的循环链表中元素m替换为n</div></button>

                                <div class="col-xs-10 col-xs-offset-1 _patent" style="display: none; float:left; padding-top: 10px;" id="3">
                                    <p><span style="font-family:宋体">将带头结点的循环链表中元素</span>m<span style="font-family:宋体">替换为</span>n<span style="font-family: 宋体">。</span></p><p><img src="./1599283688174218.jpg" title="1599283688174218.jpg" alt="cirlink_replace.jpg"></p>                                    <hr><span style="float:left; margin-right:15px;"></span><input class="answ bigAnswer" type="button" style="float:left; margin-right:20px;" value="显示答案"><input style="margin-right:15px;" type="button" name="46F263BC918F7ECF8109F72E7AA4BCB9" id="compile46F263BC918F7ECF8109F72E7AA4BCB9" value="编译该题" onclick="compile(&#39;46F263BC918F7ECF8109F72E7AA4BCB9&#39;)"><input type="button" value="还原代码" class="resetCode">
            <textarea class="Answer22 cairo_scaled_font_text_extents(scaledfont, text)" style="line-height:25px;">void replace(pCircleLink L, int m, int n)
{
	pCircleLink p = L-&gt;next;

	while (p != L)
	{
		if (p-&gt;data == m)
		{
			p-&gt;data = n;
		}
		p = p-&gt;next;
	}
}</textarea><label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分数:</label>&nbsp;&nbsp;<strong class="StuScore" style="color:red;" id="score46F263BC918F7ECF8109F72E7AA4BCB9"></strong><div class="message" style="left:0px;">请勿频繁操作</div><textarea style="display:none;" class="anCode">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _CircleLink
{
	int data;
	struct _CircleLink *next;
} CircleLink, *pCircleLink;

void Destroy(pCircleLink L);
int create(pCircleLink L);
void output(pCircleLink L);
void replace(pCircleLink L, int m, int n);

int main(void)
{
	int m, n;
	CircleLink L;

	L.next = &amp;L;

	if (create(&amp;L) &lt; 0)
	{
		return 0;
	}
	printf("原始循环链表为:\n");
	output(&amp;L);
	printf("输入需要被替换的元素m:");
	scanf("%d", &amp;m);
	printf("输入需要替换的元素n:");
	scanf("%d", &amp;n);
	replace(&amp;L, m, n);
	printf("output:\n");
	output(&amp;L);
	Destroy(&amp;L);
	return 0;
}

void Destroy(pCircleLink L)
{
	pCircleLink p, q;
	p = q = L-&gt;next;
	while (p-&gt;next != L)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}
}

int create(pCircleLink L)
{
	int number;
	pCircleLink p, q;

	p = L;
	printf("输入创建循环链表的元素(0表示结束):\n");
	scanf("%d", &amp;number);
	while (number != 0)
	{
		q = (pCircleLink)malloc(sizeof(CircleLink));
		if (q == NULL)
		{
			return -1;
		}
		q-&gt;data = number;
		q-&gt;next = p-&gt;next;
		p-&gt;next = q;
		p = q;
		scanf("%d", &amp;number);
	}
	return 1;
}

void output(pCircleLink L)
{
	pCircleLink p = L;
	while (p-&gt;next != L)
	{
		p = p-&gt;next;
		printf("%d ", p-&gt;data);
	}
	printf("\n");
}

/******start******/

/******end******/</textarea><h1></h1><textarea class="col-xs-8 Code tkCode" rows="20" name="46F263BC918F7ECF8109F72E7AA4BCB9" style="color: red;">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _CircleLink
{
	int data;
	struct _CircleLink *next;
} CircleLink, *pCircleLink;

void Destroy(pCircleLink L);
int create(pCircleLink L);
void output(pCircleLink L);
void replace(pCircleLink L, int m, int n);

int main(void)
{
	int m, n;
	CircleLink L;

	L.next = &amp;L;

	if (create(&amp;L) &lt; 0)
	{
		return 0;
	}
	printf("原始循环链表为:\n");
	output(&amp;L);
	printf("输入需要被替换的元素m:");
	scanf("%d", &amp;m);
	printf("输入需要替换的元素n:");
	scanf("%d", &amp;n);
	replace(&amp;L, m, n);
	printf("output:\n");
	output(&amp;L);
	Destroy(&amp;L);
	return 0;
}

void Destroy(pCircleLink L)
{
	pCircleLink p, q;
	p = q = L-&gt;next;
	while (p-&gt;next != L)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}
}

int create(pCircleLink L)
{
	int number;
	pCircleLink p, q;

	p = L;
	printf("输入创建循环链表的元素(0表示结束):\n");
	scanf("%d", &amp;number);
	while (number != 0)
	{
		q = (pCircleLink)malloc(sizeof(CircleLink));
		if (q == NULL)
		{
			return -1;
		}
		q-&gt;data = number;
		q-&gt;next = p-&gt;next;
		p-&gt;next = q;
		p = q;
		scanf("%d", &amp;number);
	}
	return 1;
}

void output(pCircleLink L)
{
	pCircleLink p = L;
	while (p-&gt;next != L)
	{
		p = p-&gt;next;
		printf("%d ", p-&gt;data);
	}
	printf("\n");
}

/******start******/

/******end******/</textarea>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                </div>
                            </div>
                            <h6></h6>
                                                        <div class="row 1000206" id="1000206">
                                <button name="1" "="" type="button" class="but1 btn btn-default col-xs-10 col-xs-offset-1" onclick="toggle(4)" style="background-color: rgb(251, 173, 108);"><div class="noFlow">(1 分) 4.LB2201   双向链表头插函数</div></button>

                                <div class="col-xs-10 col-xs-offset-1 _patent" style="display: none; float:left; padding-top: 10px;" id="4">
                                    <p>该程序是带头结点双向链表的基本操作。完成HeadInsert函数功能，调用该函数一次，可以在该双向链表的最前面插入一个元素。</p><p><img title="dlink2201-1.jpg" src="./16134084-bbac-4258-b774-99ca8876f55e.jpg"></p>                                    <hr><span style="float:left; margin-right:15px;"></span><input class="answ bigAnswer" type="button" style="float:left; margin-right:20px;" value="显示答案"><input style="margin-right:15px;" type="button" name="4e2fddc31a1d4263b05c07593db006db" id="compile4e2fddc31a1d4263b05c07593db006db" value="编译该题" onclick="compile(&#39;4e2fddc31a1d4263b05c07593db006db&#39;)"><input type="button" value="还原代码" class="resetCode">
            <textarea class="Answer22 cairo_scaled_font_text_extents(scaledfont, text)" style="line-height:25px;">void HeadInsert(pDoubleLink L, int data)
{
	pDoubleLink p;

	p = (pDoubleLink)malloc(sizeof(DoubleLink));
	p-&gt;data = data;

	p-&gt;right = L-&gt;right;
	p-&gt;left = L;

	if (L-&gt;right == NULL)
	{
		L-&gt;right = p;
	}
	else
	{
		L-&gt;right-&gt;left = p;
		L-&gt;right = p;
	}
}</textarea><label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分数:</label>&nbsp;&nbsp;<strong class="StuScore" style="color:red;" id="score4e2fddc31a1d4263b05c07593db006db"></strong><div class="message" style="left:0px;">请勿频繁操作</div><textarea style="display:none;" class="anCode">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _DoubleLink
{
	int data;
	struct _DoubleLink *left;
	struct _DoubleLink *right;
	int length;
} DoubleLink, *pDoubleLink;

void HeadInsert(pDoubleLink L, int data);
void Doubleout(pDoubleLink L);
void Destroy(pDoubleLink L);

int main(void)
{
	int i, n, data;
	pDoubleLink L = (pDoubleLink)malloc(sizeof(DoubleLink));		//头结点
	L-&gt;left = L-&gt;right = NULL;
	L-&gt;length = 0;

	printf("输入需要插入的元素个数:");
	scanf("%d", &amp;n);
	printf("输入需要插入的元素值(头插法)");
	for (i = 0; i &lt; n; i++)
	{
		scanf("%d", &amp;data);
		HeadInsert(L, data);
	}

	Doubleout(L);

	Destroy(L);
	free(L);
	return 0;
}

/******start******/

/******end******/

void Doubleout(pDoubleLink L)
{
	pDoubleLink p = L;
	printf("output:\n");
	while (p-&gt;right != NULL)
	{
		printf("%d ", p-&gt;right-&gt;data);
		p = p-&gt;right;
	}
	printf("\n");
	while (p != L)
	{
		printf("%d ", p-&gt;data);
		p = p-&gt;left;
	}
	printf("\n");
}

void Destroy(pDoubleLink L)
{
	pDoubleLink p, q;
	
	p = q = L-&gt;right;
	while (p != NULL)
	{
		q = p-&gt;right;
		free(p);
		p = q;
	}
}</textarea><h1></h1><textarea class="col-xs-8 Code tkCode" rows="20" name="4e2fddc31a1d4263b05c07593db006db" style="color: red;">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _DoubleLink
{
	int data;
	struct _DoubleLink *left;
	struct _DoubleLink *right;
	int length;
} DoubleLink, *pDoubleLink;

void HeadInsert(pDoubleLink L, int data);
void Doubleout(pDoubleLink L);
void Destroy(pDoubleLink L);

int main(void)
{
	int i, n, data;
	pDoubleLink L = (pDoubleLink)malloc(sizeof(DoubleLink));		//头结点
	L-&gt;left = L-&gt;right = NULL;
	L-&gt;length = 0;

	printf("输入需要插入的元素个数:");
	scanf("%d", &amp;n);
	printf("输入需要插入的元素值(头插法)");
	for (i = 0; i &lt; n; i++)
	{
		scanf("%d", &amp;data);
		HeadInsert(L, data);
	}

	Doubleout(L);

	Destroy(L);
	free(L);
	return 0;
}

/******start******/

/******end******/

void Doubleout(pDoubleLink L)
{
	pDoubleLink p = L;
	printf("output:\n");
	while (p-&gt;right != NULL)
	{
		printf("%d ", p-&gt;right-&gt;data);
		p = p-&gt;right;
	}
	printf("\n");
	while (p != L)
	{
		printf("%d ", p-&gt;data);
		p = p-&gt;left;
	}
	printf("\n");
}

void Destroy(pDoubleLink L)
{
	pDoubleLink p, q;
	
	p = q = L-&gt;right;
	while (p != NULL)
	{
		q = p-&gt;right;
		free(p);
		p = q;
	}
}</textarea>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                </div>
                            </div>
                            <h6></h6>
                                                        <div class="row 1000206" id="1000206">
                                <button name="1" "="" type="button" class="but1 btn btn-default col-xs-10 col-xs-offset-1" onclick="toggle(5)" style="background-color: rgb(251, 173, 108);"><div class="noFlow">(1 分) 5.LB2204   双向链表尾插函数创建链表</div></button>

                                <div class="col-xs-10 col-xs-offset-1 _patent" style="display: none; float:left; padding-top: 10px;" id="5">
                                    <p>该程序是带头结点双向链表的基本操作。完成CreateTail函数，该函数使用尾插法创建双向链表。</p><p><img title="dlink2204.jpg" src="./5c026dde-313f-4f41-8f2c-f6266970e2f0.jpg"></p>                                    <hr><span style="float:left; margin-right:15px;"></span><input class="answ bigAnswer" type="button" style="float:left; margin-right:20px;" value="显示答案"><input style="margin-right:15px;" type="button" name="63d5291bf61d44e88f0975e5b82572c0" id="compile63d5291bf61d44e88f0975e5b82572c0" value="编译该题" onclick="compile(&#39;63d5291bf61d44e88f0975e5b82572c0&#39;)"><input type="button" value="还原代码" class="resetCode">
            <textarea class="Answer22 cairo_scaled_font_text_extents(scaledfont, text)" style="line-height:25px;">void CreateTail(pDoubleLink L, int n)
{
	int i, data;
	pDoubleLink p, q;

	q = L;
	printf("Input:\n");
	for (i = 0; i &lt; n; i++)
	{
		scanf("%d", &amp;data);

		p = (pDoubleLink)malloc(sizeof(DoubleLink));
		p-&gt;data = data;
		p-&gt;next = q-&gt;next;
		p-&gt;prior = q;

		q-&gt;next = p;
		q = p;
	}
}</textarea><label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分数:</label>&nbsp;&nbsp;<strong class="StuScore" style="color:red;" id="score63d5291bf61d44e88f0975e5b82572c0"></strong><div class="message" style="left:0px;">请勿频繁操作</div><textarea style="display:none;" class="anCode">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _DoubleLink
{
	int data;
	struct _DoubleLink *prior;
	struct _DoubleLink *next;
	int length;
} DoubleLink, *pDoubleLink;

void CreateTail(pDoubleLink L, int n);
void Doubleout(pDoubleLink L);
void Destroy(pDoubleLink L);

int main(void)
{
	int n;
	pDoubleLink L = (pDoubleLink)malloc(sizeof(DoubleLink));		//头结点
	L-&gt;prior = L-&gt;next = NULL;
	L-&gt;length = 0;

	printf("输入需要插入的元素个数:");
	scanf("%d", &amp;n);
	CreateTail(L, n);

	Doubleout(L);

	Destroy(L);
	free(L);
	return 0;
}

/******start******/

/******end******/

void Doubleout(pDoubleLink L)
{
	pDoubleLink p = L;
	printf("output:\n");
	while (p-&gt;next != NULL)
	{
		printf("%d ", p-&gt;next-&gt;data);
		p = p-&gt;next;
	}
	printf("\n");
	while (p != L)
	{
		printf("%d ", p-&gt;data);
		p = p-&gt;prior;
	}
	printf("\n");
}

void Destroy(pDoubleLink L)
{
	pDoubleLink p, q;
	
	p = q = L-&gt;next;
	while (p != NULL)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}
}</textarea><h1></h1><textarea class="col-xs-8 Code tkCode" rows="20" name="63d5291bf61d44e88f0975e5b82572c0" style="color: red;">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _DoubleLink
{
	int data;
	struct _DoubleLink *prior;
	struct _DoubleLink *next;
	int length;
} DoubleLink, *pDoubleLink;

void CreateTail(pDoubleLink L, int n);
void Doubleout(pDoubleLink L);
void Destroy(pDoubleLink L);

int main(void)
{
	int n;
	pDoubleLink L = (pDoubleLink)malloc(sizeof(DoubleLink));		//头结点
	L-&gt;prior = L-&gt;next = NULL;
	L-&gt;length = 0;

	printf("输入需要插入的元素个数:");
	scanf("%d", &amp;n);
	CreateTail(L, n);

	Doubleout(L);

	Destroy(L);
	free(L);
	return 0;
}

/******start******/

/******end******/

void Doubleout(pDoubleLink L)
{
	pDoubleLink p = L;
	printf("output:\n");
	while (p-&gt;next != NULL)
	{
		printf("%d ", p-&gt;next-&gt;data);
		p = p-&gt;next;
	}
	printf("\n");
	while (p != L)
	{
		printf("%d ", p-&gt;data);
		p = p-&gt;prior;
	}
	printf("\n");
}

void Destroy(pDoubleLink L)
{
	pDoubleLink p, q;
	
	p = q = L-&gt;next;
	while (p != NULL)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}
}</textarea>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                </div>
                            </div>
                            <h6></h6>
                                                        <div class="row 1000206" id="1000206">
                                <button name="1" "="" type="button" class="but1 btn btn-default col-xs-10 col-xs-offset-1" onclick="toggle(6)" style="background-color: rgb(251, 173, 108);"><div class="noFlow">(1 分) 6.LB2137N   带头结点非循环双向链表，删除元素x</div></button>

                                <div class="col-xs-10 col-xs-offset-1 _patent" style="display: none; float:left; padding-top: 10px;" id="6">
                                    <p><span style="font-family:宋体">删除带头结点非循环双向链表中值为</span>x<span style="font-family:宋体">的所有结点。创建链表为尾插法，</span>0<span style="font-family:宋体">表示创建链表结束。</span></p><p><span style="font-family:宋体">图中第</span>1<span style="font-family:宋体">行的</span>3<span style="font-family: 宋体">，第</span>3<span style="font-family:宋体">行为键盘输入。</span></p><p><img src="./1602143626101129.jpg" title="1602143626101129.jpg" alt="LB2137N.jpg"></p>                                    <hr><span style="float:left; margin-right:15px;"></span><input class="answ bigAnswer" type="button" style="float:left; margin-right:20px;" value="显示答案"><input style="margin-right:15px;" type="button" name="879D453EC52D2948F142B9F250B4426F" id="compile879D453EC52D2948F142B9F250B4426F" value="编译该题" onclick="compile(&#39;879D453EC52D2948F142B9F250B4426F&#39;)"><input type="button" value="还原代码" class="resetCode">
            <textarea class="Answer22 cairo_scaled_font_text_extents(scaledfont, text)" style="line-height:25px;">void erase(Link head, int x)
{
	pNode p = head, q;
	
	while (p-&gt;next != NULL)
	{
		if (p-&gt;next-&gt;data == x)
		{
			q = p-&gt;next;
			p-&gt;next = q-&gt;next;

			if (q-&gt;next != NULL)
			{
				q-&gt;next-&gt;prior = p;
			}
			free(q);
			continue;
		}
		p = p-&gt;next;
	}
}</textarea><label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分数:</label>&nbsp;&nbsp;<strong class="StuScore" style="color:red;" id="score879D453EC52D2948F142B9F250B4426F"></strong><div class="message" style="left:0px;">请勿频繁操作</div><textarea style="display:none;" class="anCode">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _node
{
	int data;
	struct _node *next;
	struct _node *prior;
} Node, *pNode, *Link;

int create(Link *head);
void output(Link head);
void destroy(Link head);
void erase(Link head, int x);

int main(void)
{
	int flag = 0;
	int x = 0;
	Link head;

	printf("Input x:");
	scanf("%d", &amp;x);
	printf("Input data:\n");
	flag = create(&amp;head);
	if (flag &lt;= 0)
	{
		return 0;
	}
	printf("Link :\n");
	output(head);

	erase(head, x);
	printf("Output:\n");
	output(head);

	destroy(head);
	return 0;
}

int create(Link *head)
{
	int temp;
	pNode p, q;

	*head = (pNode)malloc(sizeof(Node));
	if (*head == NULL)
	{
		return -1;
	}
	(*head)-&gt;next = NULL;
	(*head)-&gt;prior = NULL;
	q = *head;

	scanf("%d", &amp;temp);
	while (temp != 0)
	{
		p = (pNode)malloc(sizeof(Node));
		if (p == NULL)
		{
			destroy(*head);
			return -1;
		}
		p-&gt;data = temp;
		q-&gt;next = p;
		p-&gt;prior = q;
		q = p;
		scanf("%d", &amp;temp);
	}
	q-&gt;next = NULL;

	return 1;
}

void output(Link head)
{
	if (head == NULL)
	{
		return ;
	}
	printf("Forward: ");
	while (head-&gt;next != NULL)
	{
		printf("%d ", head-&gt;next-&gt;data);
		head = head-&gt;next;
	}
	printf("\n");
	printf("Backward: ");
	while (head-&gt;prior != NULL)
	{
		printf("%d ", head-&gt;data);
		head = head-&gt;prior;
	}
	printf("\n");
}

void destroy(Link head)
{
	pNode p;

	while (head != NULL)
	{
		p = head-&gt;next;
		free(head);
		head = p;
	}
}

/******start******/

/******end******/</textarea><h1></h1><textarea class="col-xs-8 Code tkCode" rows="20" name="879D453EC52D2948F142B9F250B4426F" style="color: red;">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _node
{
	int data;
	struct _node *next;
	struct _node *prior;
} Node, *pNode, *Link;

int create(Link *head);
void output(Link head);
void destroy(Link head);
void erase(Link head, int x);

int main(void)
{
	int flag = 0;
	int x = 0;
	Link head;

	printf("Input x:");
	scanf("%d", &amp;x);
	printf("Input data:\n");
	flag = create(&amp;head);
	if (flag &lt;= 0)
	{
		return 0;
	}
	printf("Link :\n");
	output(head);

	erase(head, x);
	printf("Output:\n");
	output(head);

	destroy(head);
	return 0;
}

int create(Link *head)
{
	int temp;
	pNode p, q;

	*head = (pNode)malloc(sizeof(Node));
	if (*head == NULL)
	{
		return -1;
	}
	(*head)-&gt;next = NULL;
	(*head)-&gt;prior = NULL;
	q = *head;

	scanf("%d", &amp;temp);
	while (temp != 0)
	{
		p = (pNode)malloc(sizeof(Node));
		if (p == NULL)
		{
			destroy(*head);
			return -1;
		}
		p-&gt;data = temp;
		q-&gt;next = p;
		p-&gt;prior = q;
		q = p;
		scanf("%d", &amp;temp);
	}
	q-&gt;next = NULL;

	return 1;
}

void output(Link head)
{
	if (head == NULL)
	{
		return ;
	}
	printf("Forward: ");
	while (head-&gt;next != NULL)
	{
		printf("%d ", head-&gt;next-&gt;data);
		head = head-&gt;next;
	}
	printf("\n");
	printf("Backward: ");
	while (head-&gt;prior != NULL)
	{
		printf("%d ", head-&gt;data);
		head = head-&gt;prior;
	}
	printf("\n");
}

void destroy(Link head)
{
	pNode p;

	while (head != NULL)
	{
		p = head-&gt;next;
		free(head);
		head = p;
	}
}

/******start******/

/******end******/</textarea>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                </div>
                            </div>
                            <h6></h6>
                                                        <div class="row 1000206" id="1000206">
                                <button name="1" "="" type="button" class="but1 btn btn-default col-xs-10 col-xs-offset-1" onclick="toggle(7)" style="background-color: rgb(251, 173, 108);"><div class="noFlow">(1 分) 7.LB2107P   统计带头结点的循环链表中元素的个数</div></button>

                                <div class="col-xs-10 col-xs-offset-1 _patent" style="display: none; float:left; padding-top: 10px;" id="7">
                                    <p><span style="font-size:13px;font-family:宋体">统计带头结点的循环链表中元素的个数。</span></p><p><img src="./1599288842565904.jpg" title="1599288842565904.jpg" alt="cirlink_count.jpg"></p>                                    <hr><span style="float:left; margin-right:15px;"></span><input class="answ bigAnswer" type="button" style="float:left; margin-right:20px;" value="显示答案"><input style="margin-right:15px;" type="button" name="9D16E51109DBD88F74FC6A60CCA0EB30" id="compile9D16E51109DBD88F74FC6A60CCA0EB30" value="编译该题" onclick="compile(&#39;9D16E51109DBD88F74FC6A60CCA0EB30&#39;)"><input type="button" value="还原代码" class="resetCode">
            <textarea class="Answer22 cairo_scaled_font_text_extents(scaledfont, text)" style="line-height:25px;">int count(pCircleLink L)
{
	int cnt = 0;
	pCircleLink p = L;
	while (p-&gt;next != L)
	{
		cnt++;
		p = p-&gt;next;
	}
	return cnt;
}</textarea><label>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分数:</label>&nbsp;&nbsp;<strong class="StuScore" style="color:red;" id="score9D16E51109DBD88F74FC6A60CCA0EB30"></strong><div class="message" style="left:0px;">请勿频繁操作</div><textarea style="display:none;" class="anCode">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _CircleLink
{
	int data;
	struct _CircleLink *next;
} CircleLink, *pCircleLink;

void Destroy(pCircleLink L);
int create(pCircleLink L);
void output(pCircleLink L);
int count(pCircleLink L);

int main(void)
{
	int n;
	CircleLink L;

	L.next = &amp;L;

	if (create(&amp;L) &lt; 0)
	{
		return 0;
	}
	
	n = count(&amp;L);
	printf("output:\n该循环链表有%d个元素.\n", n);
	Destroy(&amp;L);
	return 0;
}

void Destroy(pCircleLink L)
{
	pCircleLink p, q;
	p = q = L-&gt;next;
	while (p-&gt;next != L)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}
}

int create(pCircleLink L)
{
	int number;
	pCircleLink p, q;

	p = L;
	printf("输入创建循环链表的元素(0表示结束):\n");
	scanf("%d", &amp;number);
	while (number != 0)
	{
		q = (pCircleLink)malloc(sizeof(CircleLink));
		if (q == NULL)
		{
			return -1;
		}
		q-&gt;data = number;
		q-&gt;next = p-&gt;next;
		p-&gt;next = q;
		p = q;
		scanf("%d", &amp;number);
	}
	return 1;
}

void output(pCircleLink L)
{
	pCircleLink p = L;
	while (p-&gt;next != L)
	{
		p = p-&gt;next;
		printf("%d ", p-&gt;data);
	}
	printf("\n");
}

/******start******/

/******end******/</textarea><h1></h1><textarea class="col-xs-8 Code tkCode" rows="20" name="9D16E51109DBD88F74FC6A60CCA0EB30" style="color: red;">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct _CircleLink
{
	int data;
	struct _CircleLink *next;
} CircleLink, *pCircleLink;

void Destroy(pCircleLink L);
int create(pCircleLink L);
void output(pCircleLink L);
int count(pCircleLink L);

int main(void)
{
	int n;
	CircleLink L;

	L.next = &amp;L;

	if (create(&amp;L) &lt; 0)
	{
		return 0;
	}
	
	n = count(&amp;L);
	printf("output:\n该循环链表有%d个元素.\n", n);
	Destroy(&amp;L);
	return 0;
}

void Destroy(pCircleLink L)
{
	pCircleLink p, q;
	p = q = L-&gt;next;
	while (p-&gt;next != L)
	{
		q = p-&gt;next;
		free(p);
		p = q;
	}
}

int create(pCircleLink L)
{
	int number;
	pCircleLink p, q;

	p = L;
	printf("输入创建循环链表的元素(0表示结束):\n");
	scanf("%d", &amp;number);
	while (number != 0)
	{
		q = (pCircleLink)malloc(sizeof(CircleLink));
		if (q == NULL)
		{
			return -1;
		}
		q-&gt;data = number;
		q-&gt;next = p-&gt;next;
		p-&gt;next = q;
		p = q;
		scanf("%d", &amp;number);
	}
	return 1;
}

void output(pCircleLink L)
{
	pCircleLink p = L;
	while (p-&gt;next != L)
	{
		p = p-&gt;next;
		printf("%d ", p-&gt;data);
	}
	printf("\n");
}

/******start******/

/******end******/</textarea>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                                </div>
                            </div>
                            <h6></h6>
                                                </div>
                </div>
                        </form>
        </div>
    </div>
</section>



<script src="./jquery.form.min.js"></script>

<!-- Bootstrap 3.3.6 -->
<script src="./bootstrap.min(2).js"></script>
<!-- Morris.js charts -->
<!-- Sparkline -->

<!-- jQuery Knob Chart -->

    

<!-- <body></body>后代码块 -->
<script>

$(document).ready(function(){
    $("input:text").each(function(index,element){
        if($(this).val()){
            $(this).closest(".row").find("button").css('background-color','#d6f8fe');
        }
    });
    $("input:radio").each(function(index,element){
        if($(this).attr("checked")){
            var selfAnsw = $(this).val();
            var rightAnsw = $(this).parent().siblings(".Answer11").html();
            rightAnsw = $.trim(rightAnsw);
            selfAnsw = $.trim(selfAnsw);
            if(selfAnsw==rightAnsw){
                $(this).parent().siblings('.grade').html("正确率：100%");
            }else{
                $(this).parent().siblings('.grade').html("正确率：0%");
            }
            $(this).closest(".row").find("button").css('background-color','#d6f8fe');
        }
    });
    $('textarea').each(function(index,element){
        if($(this).is(".Code")){
            $(this).css('color','red');
        }else if($(this).html()){
            $(this).closest(".row").find("button").css('background-color','#d6f8fe');
        }
        if($(this).is(".tkCode")){
        	$(this).closest(".row").find("button").css('background-color','#fbad6c');
        }
    });
    $('input:radio').on('click',function(){
            var selfAnsw = $(this).val();
            var rightAnsw = $(this).parent().siblings(".Answer11").html();
            var theScore = $(this).closest(".row").find("button").attr('name');
            rightAnsw = $.trim(rightAnsw);
            selfAnsw = $.trim(selfAnsw);
            if(selfAnsw==rightAnsw){
                $(this).parent().siblings('.grade').html("正确率：100%");
                tScore = 100;
            }else{
                $(this).parent().siblings('.grade').html("正确率：0%");
                tScore = 0;
            }
                $(this).closest(".row").find("button").css('background-color','#d6f8fe');
                $.ajax({
                    type: 'POST',
                    url: '/index.php?r=front%2Ftest%2Fadd-test-info',
                    dataType: "JSON",
                    data: {"QuestionBh": $(this).attr('name'), "StuAnswer":selfAnsw, "Score":tScore},
                    success: function (value) {
                   // alert('success');
                    },
                    error:function(){
                       // alert("失败！");
                    }
            })
    });

    $('input:text').blur(function(){
        if($(this).val()){
             $(this).closest('.row').children('button').css('background-color','#d6f8fe');
        }
    });

});

  $(".nav li").click(function(){
            var _rel = $(this).attr("name");
            var nn = '#'+_rel+'-href';
            var pos = $(nn).offset().top;
            $('html,iframe').animate({scrollTop:pos},300);
        });

    $(".answ").click(function(){
        if($(this).next('.Answer11').css("display")=="none")
        {
            $(this).next('.Answer11').css("display","block");
            $(this).val("隐藏答案");
        }
        else
        {
            $(this).next('.Answer11').css("display","none");
            $(this).val("显示答案");
        }
    });

    $(".resetCode").click(function(){
        var answerCode = $(this).parents("._patent").find(".anCode").val();
        $(this).parents("._patent").find(".Code").val(answerCode);
    });

    $(".bigAnswer").click(function(){
        if($(this).parents(".col-xs-10").find(".Answer22").css('display')=='none'){
            $(this).parents(".col-xs-10").find(".Answer22").css('display','block');
            $(this).val("隐藏答案");
        }else{
            $(this).parents(".col-xs-10").find(".Answer22").css('display','none');
            $(this).val("显示答案");
        }
    });

    function toggle(id) {
        var display =$('#'+id).css('display');
        if (display == 'none') {
            $('#'+id).slideDown(200);
        } else {
            $('#'+id).slideUp(200);
        }
    }

    function compile(id) {
        var CourseName = "数据结构";

        var code = $('textarea[name="'+ id +'"]').val();
        if (code == ""){
            alert("请输入代码");
        }else {
            $('#compile'+ id +'').closest(".row").find("button").css('background-color','#d6f8fe');
            $('#compile'+ id +'').val('正在编译');
            $('#compile'+ id +'').attr("disabled","disabled");
            if(CourseName=="数据库原理及其应用")
            {
                var data={
                    "stuNum":"",
                    "stuName":"",
                    "paperId":"65AAD36DAF521FF9C13A0AB1D96EE07C",
                    "questionBh": id,
                    "answer": code
                }
                var websocket = null;

                //判断当前浏览器是否支持WebSocket
                if('WebSocket' in window){
                    //console.log("Hello");
                    websocket = new WebSocket("ws://222.18.158.42:8801/producer/webSocket/"+"65AAD36DAF521FF9C13A0AB1D96EE07C&"+id);//使用websocket获取分数
                }
                else{
                    alert('Not support websocket')
                }

                //连接发生错误的回调方法
                websocket.onerror = function(){
                    $('#score' + id + '').text("连接失败");
                };

                //连接成功建立的回调方法
                websocket.onopen = function(event){
                    $('#score' + id + '').text("正在编译");
                    //setMessageInnerHTML("open");
                }

                //接收到消息的回调方法
                websocket.onmessage = function(event){
                    //console.log("Receive");
                    setMessageInnerHTML(event.data);
                }

                //连接关闭的回调方法
                websocket.onclose = function(){
                    //setMessageInnerHTML("close");
                }

                //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。
                window.onbeforeunload = function(){
                    websocket.close();
                }

                //将消息显示在网页上
                function setMessageInnerHTML(score){
                    //console.log(score);
                    $('#compile'+ id +'').val('编译该题');
                    $('#score' + id + '').text(score);
                    closeWebSocket();
                }

                //关闭连接
                function closeWebSocket(){
                    //console.log("close");
                    websocket.close();
                }
                $.ajax({
                    type: 'POST',
                    url: 'http://222.18.158.42:8801/producer/compile/student',
                    contentType:'application/json;charset=UTF-8',
                    dataType: "JSON",
                    data: JSON.stringify(data),
                    success: function (data) {
                        $('#compile'+ id +'').val('编译该题');
                        //$('#score' + id + '').text(data.msg);
                    },
                    error:function(){
                        $('#compile'+ id +'').text('编译该题');
                        $('#score' + id + '').text('编译失败');
                        $('#compile'+ id +'').removeAttr('disabled');
                    }
                })
            }else{
                $.ajax({
                    type: 'POST',
                    url: '/index.php?r=common%2Fcompile',
                    dataType: "JSON",
                    data: {"id": id, "code": code},
                    success: function (value) {
                        $('#compile'+ id +'').val('编译该题');
                        // $('#compile'+ id +'').removeAttr('disabled');
                        $('#score' + id + '').text(value);
                        var tScore = value;
                        var selfAnsw = code;
                        $.ajax({
                            type:'POST',
                            url:'/index.php?r=front%2Ftest%2Fadd-test-info',
                            dataType: "JSON",
                            data: {"QuestionBh": id, "StuAnswer":selfAnsw, "Score":tScore},
                            success: function (content){
                                // alert('success');
                            },
                            error:function(){
                                // alert("失败！");
                            }
                        });
                    },
                    error:function(){
                        // alert("编译失败！");
                        $('#compile'+ id +'').val('编译该题');
                        $('#score' + id + '').text('编译失败');
                        $('#compile'+ id +'').removeAttr('disabled');
                    }
                });
            }
            var waitTime = 0;
            $("#compile"+id+'').bind('mouseover',function(){
                $(this).siblings('.message').css('display','block');
            });
            $("#compile"+id+'').bind('mouseout',function(){
                $(this).siblings('.message').css('display','none');
            });
            setTimeout(function(){
                waitTime++;
                if(waitTime==1){
                    $("#compile"+id+'').removeAttr('disabled');
                    $("#compile"+id+'').unbind('mouseover');
                    $("#compile"+id+'').unbind('mouseout');
                }
            },5000)

        }
    }

    $(".nav li").click(function(){
        var _rel = $(this).attr("name");
        var pos = $('#'+_rel).offset().top;
        $("html,body").animate({scrollTop:pos},300);
    });

     $(".TKanswer").click(function(){
         if($(this).val()=='隐藏答案'){
            var mythis = $(this);
            $.ajax({
            type:'POST',
            url:'/index.php?r=front%2Ftest%2Fget-fill-answer',
           // dataType:"json",
            data:{"QuestionBh":$(this).attr('name')},
            success:function(data){
                //alert("成功");
                var obj = eval(data);
                for(var i in obj){
                    var answer = obj[i].Answer;
                    mythis.next(".Answer11").children("input:eq("+i+")").val(answer);
                }
                //$(this).next(".Answer11").html(data);
            },
            error:function(){
             //  alert("error");
            }
        })
        }
    })
     $(".JDanswer").click(function(){
        if($(this).val()=='隐藏答案'){
            var mythis = $(this);
             $.ajax({
            type:'POST',
            url:'/index.php?r=front%2Ftest%2Fget-correct-answer',
            dataType:"json",
            data:{"QuestionBh":$(this).attr('name')},
            success:function(data){
                for(var i in data){
                    var answer = data[i].Answer[0];
                    var _index = data[i].ErrorCount-1;
                    for(var key in answer){
                        if(key=='Answer'){
                           mythis.next(".Answer11").children("input:eq("+_index+")").val(answer[key]);
                        }
                    }
                }
            },
            error:function(){
              //  alert("error");
            }
        })
        }
    })
</script>

</body></html>